<!DOCTYPE html>

<!-- С���� -->
<script type="text/javascript" src="/js/src/love.js"></script>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="B树 B+树 红黑树," />










<meta name="description" content="前言 mysql的索引基于B+树，java中的treemap基于红黑树，java中的hashmap在1.8版本后链表长度大于8时转为红黑树…今天就总结一下常见的数据结构B树、B+树和红黑树。">
<meta name="keywords" content="B树 B+树 红黑树">
<meta property="og:type" content="article">
<meta property="og:title" content="B树、B+树、红黑树总结">
<meta property="og:url" content="https://mameba.github.io/2018/08/02/tags- B树 B+树 红黑树/index.html">
<meta property="og:site_name" content="mameba&#39;s blog">
<meta property="og:description" content="前言 mysql的索引基于B+树，java中的treemap基于红黑树，java中的hashmap在1.8版本后链表长度大于8时转为红黑树…今天就总结一下常见的数据结构B树、B+树和红黑树。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.imgur.com/SqU3btN.png">
<meta property="og:image" content="https://i.imgur.com/xDw3HLP.png">
<meta property="og:image" content="https://i.imgur.com/n3xv9lm.png">
<meta property="og:image" content="https://i.imgur.com/ygU5EQ8.png">
<meta property="og:image" content="https://i.imgur.com/YM7dG1x.png">
<meta property="og:image" content="https://i.imgur.com/aw2EKZJ.png">
<meta property="og:image" content="https://i.imgur.com/XOcSqyK.png">
<meta property="og:image" content="https://i.imgur.com/Cz3etod.png">
<meta property="og:image" content="https://i.imgur.com/M5gDO3d.png">
<meta property="og:image" content="https://i.imgur.com/CZMv6de.jpg">
<meta property="og:image" content="https://i.imgur.com/M7x1NU8.png">
<meta property="og:image" content="https://i.imgur.com/jszIUzG.png">
<meta property="og:image" content="https://i.imgur.com/LhutIJl.png">
<meta property="og:image" content="https://i.imgur.com/eovHNOn.png">
<meta property="og:image" content="https://i.imgur.com/GSI8CyD.png">
<meta property="og:image" content="https://i.imgur.com/TCQxEoq.png">
<meta property="og:image" content="https://i.imgur.com/PTDL6aO.jpg">
<meta property="og:image" content="https://i.imgur.com/IzB3vF4.png">
<meta property="og:image" content="https://i.imgur.com/qk6t4v7.png">
<meta property="og:image" content="https://i.imgur.com/SY944sG.png">
<meta property="og:image" content="https://i.imgur.com/SY944sG.png">
<meta property="og:image" content="https://i.imgur.com/XOVsyTn.jpg">
<meta property="og:image" content="https://i.imgur.com/uADQpeg.jpg">
<meta property="og:image" content="https://i.imgur.com/gLrWlK5.jpg">
<meta property="og:image" content="https://i.imgur.com/x97FtiS.jpg">
<meta property="og:image" content="https://i.imgur.com/FE4D66Y.png">
<meta property="og:image" content="https://i.imgur.com/MbzwIGZ.png">
<meta property="og:image" content="https://i.imgur.com/aKIQDEE.png">
<meta property="og:image" content="https://i.imgur.com/6bD3SH8.png">
<meta property="og:image" content="https://i.imgur.com/2sjxlCF.png">
<meta property="og:image" content="https://i.imgur.com/OYA3bH1.png">
<meta property="og:updated_time" content="2018-08-13T02:35:36.747Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="B树、B+树、红黑树总结">
<meta name="twitter:description" content="前言 mysql的索引基于B+树，java中的treemap基于红黑树，java中的hashmap在1.8版本后链表长度大于8时转为红黑树…今天就总结一下常见的数据结构B树、B+树和红黑树。">
<meta name="twitter:image" content="https://i.imgur.com/SqU3btN.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://mameba.github.io/2018/08/02/tags- B树 B+树 红黑树/"/>





  <title>B树、B+树、红黑树总结 | mameba's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mameba's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">mameba.github.io</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mameba.github.io/2018/08/02/tags- B树 B+树 红黑树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang ChenYang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mameba's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">B树、B+树、红黑树总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-02T11:19:57+08:00">
                2018-08-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,739 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  28 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<p>mysql的索引基于B+树，java中的treemap基于红黑树，java中的hashmap在1.8版本后链表长度大于8时转为红黑树…今天就总结一下常见的数据结构<code>B树</code>、<code>B+树</code>和<code>红黑树</code>。<br><a id="more"></a></p>
<h1 id="1-B树"><a href="#1-B树" class="headerlink" title="1. B树"></a>1. B树</h1><hr>
<p>B树是一种自平衡的树，其查找、顺序访问、插入数据及删除数据的操作的时间复杂度为<code>O(logn)</code>。与二叉查找树不同的是，它的子结点数目可以大于2。</p>
<h2 id="1-1-基本原理"><a href="#1-1-基本原理" class="headerlink" title="1.1 基本原理"></a>1.1 基本原理</h2><p>首先，简单说一下B树产生的原因。B树是一种<code>查找树</code>，我们知道，这一类树（比如二叉查找树，红黑树等等）最初生成的目的都是为了<strong>解决某种系统中，查找效率低的问题</strong>。B树也是如此，它最初启发于二叉查找树，二叉查找树的特点是每个非叶节点都只有两个孩子节点。然而这种做法会导致当数据量非常大时，二叉查找树的深度过深，搜索算法自根节点向下搜索时，需要访问的节点也就变的相当多。<strong>如果这些节点存储在外存储器中，每访问一个节点，相当于就是进行了一次I/O操作，随着树高度的增加，频繁的I/O操作一定会降低查询的效率</strong>。</p>
<p>这里有一个基本的概念，就是说我们从外存储器中读取信息的步骤，简单来分，大致有两步：</p>
<ul>
<li>找到存储这个数据所对应的磁盘页面，这个过程是机械化的过程，需要依靠磁臂的转动，找到对应磁道，所以耗时长。</li>
<li>读取数据进内存，并实施运算，这是电子化的过程，相当快。</li>
</ul>
<p>综上，<strong>对于外存储器的信息读取最大的时间消耗在于寻找磁盘页面</strong>。那么一个基本的想法就是能不能减少这种读取的次数，在一个磁盘页面上，多存储一些索引信息。<strong>B树的基本逻辑就是这个思路，它要改二叉为多叉，每个节点存储更多的指针信息，以降低I/O操作数</strong>。</p>
<h2 id="1-2-基本结构"><a href="#1-2-基本结构" class="headerlink" title="1.2 基本结构"></a>1.2 基本结构</h2><p>有关于B树概念的定义，不同的资料在表述上有所差别。我在这里采用《算导》中的定义，用最小度<code>t</code>来定义B树。一棵最小度为t的B树是满足如下<code>四个条件</code>的平衡多叉树：</p>
<ul>
<li><p>每个节点最多包含<code>2t−1</code>个关键字；除根节点外的每个节点至少有<code>t−1</code>个关键字（t≤2），根节点至少有<code>一个</code>关键字；</p>
</li>
<li><p>一个节点u中的关键字按<code>非降序</code>排列：u.key1≤u.key2≤…u.keyn；</p>
</li>
<li><p><code>每个节点的关键字对其子树的范围分割</code>。设节点u有n+1个指针，指向其n+1棵子树，指针为u.p1,…u.pn，关键字ki为u.pi所指的子树中的关键字，有k1≤u.key1≤k2≤u.key2…成立；</p>
</li>
<li><p><code>所有叶子节点具有相同的深度</code>，即树的高度h。这表明B树是平衡的。平衡性其实正是B树名字的来源，B表示的正是单词Balanced；</p>
</li>
</ul>
<p>一个标准的B树如下图：</p>
<p><img src="https://i.imgur.com/SqU3btN.png" alt=""></p>
<h2 id="1-3-查找关键字"><a href="#1-3-查找关键字" class="headerlink" title="1.3 查找关键字"></a>1.3 查找关键字</h2><p>  一棵已经建立好的B树如下图所示，我们的目的是查找关键字为29的文件：</p>
<p><img src="https://i.imgur.com/xDw3HLP.png" alt=""></p>
<p>先简单对上图说明一下：</p>
<ul>
<li><p>图中的小红方块表示对应关键字所代表的<code>文件的存储位置</code>，实际上可以看做是一个<code>地址</code>，比如根节点中17旁边的小红块表示的就是关键字17所对应的文件在硬盘中的存储地址。</p>
</li>
<li><p>P是指针，不用多说了，需要注意的是：<code>指针</code>，<code>关键字</code>，以及<code>关键字所代表的文件地址</code>这三样东西合起来构成了B树的一个节点，这个节点存储在一个磁盘块上</p>
</li>
</ul>
<p>下面，看看搜索关键字的29的文件的过程：</p>
<ol>
<li><p>从<code>根节点</code>开始，读取根节点信息，根节点有2个关键字：17和35。因为17 &lt; 29 &lt; 35，所以找到指针P2指向的子树，也就是磁盘块3（1次I/0操作）</p>
</li>
<li><p>读取当前节点信息，当前节点有2个关键字：26和30。26 &lt; 29 &lt; 30，找到指针P2指向的子树，也就是磁盘块8（2次I/0操作）</p>
</li>
<li><p>读取当前节点信息，当前节点有2个关键字：28和29。找到了！（3次I/0操作）</p>
</li>
</ol>
<p>由上面的过程可见，同样的操作，如果使用平衡二叉树，那么需要至少4次I/O操作，B树比之二叉树的这种优势，还会随着节点数的增加而增加。另外，因为B树节点中的关键字都是排序好的，所以，在节点中的信息被读入内存之后，可以采用<strong>二分查找</strong>这种快速的查找方式，更进一步减少了读入内存之后的计算时间，由此更能说明<strong>对于外存数据结构来说，I/O次数是其查找信息中最大的时间消耗</strong>，而我们要做的所有努力就是尽量在搜索过程中减少I/O操作的次数。</p>
<h2 id="1-4-插入关键字"><a href="#1-4-插入关键字" class="headerlink" title="1.4 插入关键字"></a>1.4 插入关键字</h2><p>向B树种插入关键字的过程与向二叉查找树中插入关键字的过程类似，但是要稍微复杂一点，因为根据上面B树的定义，我们可以看出，<strong>B树每个节点中关键字的个数是有范围要求的</strong>，同时，B树是平衡的，所以，如果像二叉查找树那样，直接找到相关的叶子，插入关键字，有可能会导致B树的结构发生变化而这种变化会使得B树不再是B树。</p>
<p>所以，我们这样来设计B树种对新关键字的插入：</p>
<ol>
<li><code>首先找到要插入的关键字应该插入的叶子节点</code>（为方便描述，设这个叶子节点为u），</li>
<li>如果u是满的（恰好有2t−1个关键字），那么由于不能将一个关键字插入满的节点，我们需要对u按其当前排在<code>中间关键字u.keyt进行分裂，分裂成两个节点u1,u2</code>；</li>
<li>作为分裂标准的关键字u.keyt会被上移到u的父节点中，在u.keyt插入前，如果u的父节点未满，则直接插入即可；</li>
<li>如果u的父节点已满，则<code>按照上面的方法对u的父节点分裂</code>，这个过程如果一直不停止的话，最终会导致B树的根节点分裂，B树的高度增加一层。</li>
</ol>
<p>我用《算导》中的一个题目展示一下这种插入关键字的过程：</p>
<p>现在我们要将关键字序列：F, S, Q, K, C, L, H, T, V, W, M, R, N, P, A, B, X, Y依次插入一棵<strong>最小度为2的B树</strong>中。也就是说，这棵树的节点中，最多有3个关键字，最少有1个关键字。</p>
<ul>
<li><p><strong>第一步</strong>，首先插入F，S，Q当做根结点；</p>
<p><img src="https://i.imgur.com/n3xv9lm.png" alt=""></p>
</li>
<li><p><strong>第二步</strong>，插入结点k，因为根结点已经满了，结点分裂成两个，中间关键字Q上移，建立一个新的根结点；</p>
</li>
</ul>
<p><img src="https://i.imgur.com/ygU5EQ8.png" alt=""></p>
<ul>
<li><strong>第三步</strong>，插入关键字C；</li>
</ul>
<p><img src="https://i.imgur.com/YM7dG1x.png" alt=""></p>
<ul>
<li><strong>第四步</strong>，插入关键字L，关键字L应该插在根结点的左孩子结点中，左孩子结点已满，分裂，中间关键字F上移；</li>
</ul>
<p><img src="https://i.imgur.com/aw2EKZJ.png" alt=""></p>
<ul>
<li><strong>第五步</strong>，直接插入关键字H，T，V；</li>
</ul>
<p><img src="https://i.imgur.com/XOcSqyK.png" alt=""></p>
<ul>
<li><strong>第六步</strong>，插入关键字W，结点已满，中间关键字T上移；</li>
</ul>
<p><img src="https://i.imgur.com/Cz3etod.png" alt=""></p>
<ul>
<li><strong>第七步</strong>，插入关键字M，结点已满，中间关键字K上移，K上移导致根结点满，根结点的中间关键字K上移，重新生成新的根结点；</li>
</ul>
<p><img src="https://i.imgur.com/M5gDO3d.png" alt=""></p>
<ul>
<li><strong>第八步</strong>，重复上述情况，依次插入关键字R, N, P, A, B, X, Y。得到如下B树。</li>
</ul>
<p><img src="https://i.imgur.com/CZMv6de.jpg" alt=""></p>
<h2 id="1-5-删除关键字"><a href="#1-5-删除关键字" class="headerlink" title="1.5 删除关键字"></a>1.5 删除关键字</h2><p>删除操作的基本思想和插入操作是一样的，都是不能因为关键字的改变而改变B树的结构。插入操作主要防止的是某个结点中关键字的个数太多，所以采用了分裂；删除则是要防止某个结点中，<code>因删除了关键字而导致这个结点的关键字个数太少，所以采用了合并操作</code>。</p>
<p>下面分三种情况来讨论下删除操作是如何工作的，这个过程的顺序是自根结点起向下遍历B树</p>
<p>case1： 如果要删除的关键字k是<code>叶子结点</code>，那么直接删除;</p>
<p>case2： 如果要删除的关键字k在结点x中，而且x是<code>内部结点</code>，那么分以下2种情况讨论：</p>
<ul>
<li>a. 结点x中位于k之前或之后的子结点y至少有t个关键词，则找出k在以y为根的子树中的前驱或后继k，递归删除k并在x中用k`代替k； </li>
<li>b. 若结点x中位于k之前或之后的子结点y和z都只有t-1个关键词，则将k和z中所有关键词合并进y（使y有2t-1个关键词），再删除z结点，删除k关键词。 </li>
</ul>
<p>case3： 如果要删除的关键字k不在当前结点x中，而且x是内部节点（如果自上而下扫描到叶子都没有这个关键字的话，那就说明要删除的关键字根本就不存在，所以此处只考虑x是内部结点的情况），则首先确定包含k的x的子树，我们这里设为x.pi。如果x.pi中至少含有t个关键字，那么继续扫描，寻找下一个要被扫描的子树；如果x.pi中只含有t−1个关键字，则需要分下面两种情况进行操作：              </p>
<ul>
<li>a. 如果x.pi至少有一个相邻的兄弟比较“丰满”（即这个兄弟至少有t个关键字）。则将x中的一个关键字降至x.pi，同时令x.pi的最“丰满”的兄弟中升一个关键至u。然后继续扫描B树，寻找k； </li>
<li>b. 如果x.pi的两个相邻的兄弟都不“丰满”（都只有t−1个关键字）。则令x.pi和其一个兄弟合并，再将x的一个关键字降至新合并的结点。使之成为该结点的中间关键字。 </li>
</ul>
<p>举个例子，就可以清晰看到上面说的这几种删除的情况。拿下图所示的最小度为3的B树为例（即树中除根和叶子之外的结点只能有2，3，4三种情况的关键字个数）：</p>
<p><img src="https://i.imgur.com/M7x1NU8.png" alt=""></p>
<ol>
<li>删除关键字F，符合case1，直接删除；</li>
</ol>
<p><img src="https://i.imgur.com/jszIUzG.png" alt=""></p>
<ol start="2">
<li>删除关键字M，符合case2-a，用其之前子结点（之前子结点有3个关键字）关键字L代替；</li>
</ol>
<p><img src="https://i.imgur.com/LhutIJl.png" alt=""></p>
<ol start="3">
<li>删除关键字G，符合case2-b（G的前后子结点的关键字数都小于3），合并前后子结点，删除关键字G；</li>
</ol>
<p><img src="https://i.imgur.com/eovHNOn.png" alt=""></p>
<ol start="4">
<li>删除关键字D，符合case3-b（CL结点和它的兄弟结点关键字数都小于3），合并CL结点和它的兄弟结点，并降关键字P至新合并的结点；</li>
</ol>
<p><img src="https://i.imgur.com/GSI8CyD.png" alt=""></p>
<ol start="5">
<li>删除关键字B，符合case3-a（相邻的兄弟结点关键字数为3），关键字C从父结点替换关键字B，兄弟结点中的关键字E替换关键字C。</li>
</ol>
<p><img src="https://i.imgur.com/TCQxEoq.png" alt=""></p>
<p>下面总结一下B树的删除原理：</p>
<ul>
<li><p>基本原则是不能破坏关键字个数的限制；</p>
</li>
<li><p>如果在当前节点中，找到了要删的关键字，且当前节点为内部节点。那么，如果有比较丰满的前驱或后继，借一个上来，再把要删的关键字降下去，在子树中递归删除；如果没有比较丰满的前驱或后继，则令前驱与后继合并，把要删的关键字降下去，递归删除；</p>
</li>
<li><p>如果在当前节点中，还未找到要删的关键字，且当前节点为内部节点。那么去找下一步应该扫描的孩子，并判断这个孩子是否丰满，如果丰满，继续扫描；如果不丰满，则看其有无丰满的兄弟，有的话，从父亲那里接一个，父亲再找其最丰满的兄弟借一个；如果没有丰满的兄弟，则合并，再令父亲下降，以保证B树的结构。</p>
</li>
</ul>
<h1 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2. B+树"></a>2. B+树</h1><h2 id="2-1-基本原理"><a href="#2-1-基本原理" class="headerlink" title="2.1 基本原理"></a>2.1 基本原理</h2><p>B+树是应文件系统所需而出的<code>一种B树的变型树</code>。<strong>一棵m阶的B+树和m阶的B-树的差异在于：</strong></p>
<ul>
<li><code>非叶子结点的子树指针与关键字个数相同</code>;，每个<code>关键字不保存数据，只用来索引</code>，所有<code>数据都保存在叶子节点</code>。（B树的子树的个数总比关键字个数多1个，B+树中，内部节点仅仅起到索引的作用）</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且<code>叶子结点本身依关键字的大小自小而大顺序链接</code>。</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。<br><strong>通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点</strong>。</li>
</ul>
<p><img src="https://i.imgur.com/PTDL6aO.jpg" alt=""><br>注：<code>卫星数据</code>指索引元素所指向的数据记录，比如数据库中的某一行。在B树中，所有结点（根结点、中间结点和叶子结点）都带有卫星数据。</p>
<p><strong>B+树的优势：</strong><br>我们可以发现B+树相比于B树，在文件系统，数据库系统当中，更有优势，原因如下：</p>
<ul>
<li><p><strong>B+树的磁盘读写代价更低</strong>。B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说I/O读写次数也就降低了。</p>
</li>
<li><p><strong>B+树的查询效率更加稳定</strong>。 由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
<li><p><strong>B+树更有利于对数据库的扫描</strong>。 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题（范围查询时，B树需要中序遍历），而B+树只需要遍历叶子节点就可以解决对全部关键字信息的扫描，所以对于数据库中频繁使用的range query，B+树有着更高的性能。</p>
</li>
</ul>
<h2 id="2-2-查找关键字"><a href="#2-2-查找关键字" class="headerlink" title="2.2 查找关键字"></a>2.2 查找关键字</h2><p>在B+树上查找关键字时，若在非叶子结点上有关键字等于给定值，并不终止，而是继续向下直到叶子结点（因为B+非叶子结点没有指向关键字具体信息的指针）。因此，<code>在B+树上不管查找成功与否，每次查找都是走了一条从根节点到叶子结点的路径</code>，由于B+树是平衡的，使得B+树每次查找路径长度相同。</p>
<p>如在上图中查找关键字35：</p>
<ol>
<li><p>从根节点开始，读取根结点信息，28&lt;35&lt;65，根据关键字28的索引找到子树；</p>
</li>
<li><p>读取当前结点信息，有3个关键字，关键字35是要查找的数据，根据关键字35的索引找到子树；</p>
</li>
<li><p>遍历叶子结点的链表，找到关键字35， 根据卫星数据的指针获取数据。</p>
</li>
</ol>
<h2 id="2-3-添加关键字"><a href="#2-3-添加关键字" class="headerlink" title="2.3 添加关键字"></a>2.3 添加关键字</h2><p>简单描述一下插入时的情况：</p>
<ol>
<li>根据插入值的大小，逐步向下直到找到对应的结点。</li>
<li>如果结点中的关键字个数小于阶数，则直接插入值或者更新卫星数据；</li>
<li>如果插入之前结点已经满了，则分裂该结点（与B树类似，就不上图介绍了），把中间值提上到父结点的关键字中；</li>
<li>如果这导致父结点满了的话，则把该父结点分裂，如此递归向上。</li>
</ol>
<p>B+树的高度是一层层的增加的，叶子结点永远都在同一深度。</p>
<h2 id="2-4-删除关键字"><a href="#2-4-删除关键字" class="headerlink" title="2.4 删除关键字"></a>2.4 删除关键字</h2><p>和B树删除操作类似，附上网上总结的情况：</p>
<p><img src="https://i.imgur.com/IzB3vF4.png" alt=""></p>
<p><img src="https://i.imgur.com/qk6t4v7.png" alt=""></p>
<h1 id="3-红黑树"><a href="#3-红黑树" class="headerlink" title="3. 红黑树"></a>3. 红黑树</h1><hr>
<h2 id="3-1-基本原理"><a href="#3-1-基本原理" class="headerlink" title="3.1 基本原理"></a>3.1 基本原理</h2><p>红黑树是一棵自平衡二叉查找树，但不是一棵完全平衡二叉树，查找、删除和新增等操作的时间复杂度均为: <code>O(lgn)</code>，效率是很高的。</p>
<p>红黑树是在普通二叉树上，对没个节点添加一个颜色属性形成的，同时整个红黑二叉树需要同时满足一下五条性质<br>红黑树需要满足的五条性质： </p>
<ul>
<li><p><strong>性质一：结点是红色或者是黑色；</strong><br>在树里面的结点不是红色的就是黑色的，没有其他颜色，要不怎么叫红黑树呢，是吧。 </p>
</li>
<li><p><strong>性质二：根结点是黑色；</strong><br>根结点总是黑色的。它不能为红。 </p>
</li>
<li><p><strong>性质三：每个叶结点（NIL或空结点）是黑色;</strong></p>
</li>
<li><p><strong>性质四：每个红色结点的两个子结点都是黑色的（也就是说不存在两个连续的红色结点）；</strong><br>就是连续的两个结点不能是连续的红色，连续的两个结点的意思就是父结点与子结点不能是连续的红色。</p>
</li>
<li><p><strong>性质五：从根结点到任一叶结点的路径都包含相同数目的黑色结点；</strong>这就保证了一棵红黑树中的最长路径不会大于最短路径的2倍（因为所有路径的黑色结点相同，红色结点&lt;黑色结点）。</p>
</li>
</ul>
<p>下图是一棵红黑树，可以结合五条性质来看。</p>
<p><img src="https://i.imgur.com/SY944sG.png" alt=""></p>
<h2 id="3-2-为什么有红黑树？"><a href="#3-2-为什么有红黑树？" class="headerlink" title="3.2 为什么有红黑树？"></a>3.2 为什么有红黑树？</h2><p><strong>设计红黑树的目的</strong></p>
<ul>
<li>就是解决平衡树的维护起来比较麻烦的问题，红黑树，读取略逊于AVL，维护强于AVL，每次插入和删除的平均旋转次数应该是远小于平衡树。</li>
<li>平衡树（AVL）更平衡，结构上更加直观，时间效能针对读取而言更高，但是维护起来比较麻烦！！！（插入和删除之后，都需要rebalance）。但是，红黑树通过它规则的设定，确保了插入和删除的最坏的时间复杂度是<code>O(log N)</code> 。</li>
</ul>
<p><strong>红黑树 和 b+树的用途有什么区别？</strong></p>
<ul>
<li><p>红黑树多用在<code>内部排序</code>，即全放在内存中的，STL的map和set的内部实现就是红黑树。</p>
</li>
<li><p>B+树多用于<code>外存</code>上时，B+也被成为一个磁盘友好的数据结构。</p>
</li>
</ul>
<h2 id="3-3-查找操作"><a href="#3-3-查找操作" class="headerlink" title="3.3 查找操作"></a>3.3 查找操作</h2><p>红黑树是一种自平衡的二叉查找树，查找时使用<code>二分查找</code>，<strong>一次查找所需的最大次数等同于二叉树的高度</strong>。<br><img src="https://i.imgur.com/SY944sG.png" alt=""></p>
<p>例如：查找值为22的结点。</p>
<ol>
<li>查看根结点13；</li>
<li>根结点13&lt;22，查看右孩子17；</li>
<li>17&lt;22，查看右孩子25；</li>
<li>25&gt;22,查看左孩子22，找到结点。</li>
</ol>
<h2 id="3-3-旋转操作"><a href="#3-3-旋转操作" class="headerlink" title="3.3 旋转操作"></a>3.3 旋转操作</h2><p>红黑树的基本操作是添加、删除。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的结点之后，红黑树就发生了变化，可能不满足红黑树的5条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，<strong>旋转的目的是让树保持红黑树的特性</strong>。</p>
<p>旋转包括两种：<code>左旋</code>和<code>右旋</code>。下面分别对它们进行介绍。</p>
<p><strong>左旋</strong></p>
<p><img src="https://i.imgur.com/XOVsyTn.jpg" alt=""><br>对X进行左旋，意味着<code>将x变成一个左结点</code></p>
<p>左旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解“红黑树T的节点x进行左旋”是如何进行的。</p>
<pre><code>LEFT-ROTATE(T, x)  
  y ← right[x]// 前提：这里假设x的右孩子为y。下面开始正式操作
  right[x] ← left[y]  // 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子
  p[left[y]] ← x  // 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x
  p[y] ← p[x] // 将 “x的父亲” 设为 “y的父亲”
  if p[x] = nil[T]   
  then root[T] ← y // 情况1：如果 “x的父亲” 是空节点，则将y设为根节点
  else if x = left[p[x]]  
then left[p[x]] ← y// 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
else right[p[x]] ← y   // 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子”
  left[y] ← x // 将 “x” 设为 “y的左孩子”
  p[x] ← y// 将 “x的父节点” 设为 “y”
</code></pre><p>理解左旋之后，看看下面一个更鲜明的例子。你可以先不看右边的结果，自己尝试一下。<br><img src="https://i.imgur.com/uADQpeg.jpg" alt=""></p>
<p><strong>右旋</strong></p>
<p><img src="https://i.imgur.com/gLrWlK5.jpg" alt=""><br>对Y进行右旋，意味着<code>将Y变成一个右结点</code></p>
<p>右旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解“红黑树T的节点y进行右旋”是如何进行的。</p>
<pre><code>RIGHT-ROTATE(T, y)  
  x ← left[y] // 前提：这里假设y的左孩子为x。下面开始正式操作
  left[y] ← right[x]  // 将 “x的右孩子” 设为 “y的左孩子”，即 将β设为y的左孩子
  p[right[x]] ← y // 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y
  p[x] ← p[y] // 将 “y的父亲” 设为 “x的父亲”
  if p[y] = nil[T]   
  then root[T] ← x // 情况1：如果 “y的父亲” 是空节点，则将x设为根节点
  else if y = right[p[y]]  
then right[p[y]] ← x   // 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子”
else left[p[y]] ← x// 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩子”
  right[x] ← y// 将 “y” 设为 “x的右孩子”
  p[y] ← x// 将 “y的父节点” 设为 “x”
</code></pre><p>理解右旋之后，看看下面一个更鲜明的例子。你可以先不看右边的结果，自己尝试一下。</p>
<p><img src="https://i.imgur.com/x97FtiS.jpg" alt=""></p>
<h2 id="3-4-插入操作"><a href="#3-4-插入操作" class="headerlink" title="3.4 插入操作"></a>3.4 插入操作</h2><p>将一个结点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将结点插入；然后，将结点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下：</p>
<p><strong>第一步: 将红黑树当作一颗二叉查找树，将结点插入。</strong><br>       红黑树本身就是一颗二叉查找树，将结点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。<br>       好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！</p>
<p><strong>第二步：将插入的结点着色为”红色”。</strong><br>       为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：<br>(1) 每个结点或者是黑色，或者是红色。<br>(2) 根结点是黑色。<br>(3) 每个叶子结点是黑色。 [注意：这里叶子结点，是指为空的叶子结点！]<br>(4) 如果一个结点是红色的，则它的子结点必须是黑色的。<br>(5) 从一个结点到该结点的子孙结点的所有路径上包含相同数目的黑结点。<br>       将插入的结点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。o(∩∩)o…哈哈</p>
<p><strong>第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。</strong><br>       第二步中，将插入结点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？<br>       对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。<br>       对于”特性(2)”，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根结点。所以，根节点仍然是黑色。<br>       对于”特性(3)”，显然不会违背了。这里的叶子结点是指的空叶子结点，插入非空结点并不会对它们造成影响。<br>       对于”特性(4)”，是有可能违背的！<br>       那接下来，想办法使之”满足特性(4)”，就可以将树重新构造成红黑树了。</p>
<p>根据被插入节点的父结点的情况，可以将”当结点z被着色为红色节点，并插入二叉树”划分为三种情况来处理。</p>
<p> <strong>1. 被插入的结点是根结点。</strong><br>    处理方法：直接把此节点涂为黑色。</p>
<p> <strong>2. 被插入的结点的父结点是黑色。</strong><br>    处理方法：什么也不需要做。节点被插入后，仍然是红黑树。</p>
<p> <strong>3. 被插入的结点的父结点是红色。</strong><br>    处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入结点是一定存在非空祖父结点的；进一步的讲，被插入结点也一定存在叔叔结点(即使叔叔结点为空，我们也视之为存在，空结点本身就是黑色结点)。理解这点之后，我们依据”叔叔结点的情况”，将这种情况进一步划分为3种情况(Case)。</p>
<ul>
<li><strong>Case1: 当前结点的父结点是红色，且当前结点的祖父结点的另一个子结点（叔叔结点）也是红色。</strong>    </li>
</ul>
<p><img src="https://i.imgur.com/FE4D66Y.png" alt=""></p>
<pre><code>平衡操作：

(01) 将“父结点”设为黑色。

(02) 将“叔叔结点”设为黑色。

(03) 将“祖父结点”设为“红色”。

(04) 将“祖父结点”设为“当前结点”(红色节点)；即，之后继续对“当前结点”进行操作。
</code></pre><p><img src="https://i.imgur.com/MbzwIGZ.png" alt=""></p>
<ul>
<li><strong>Case2: 当前结点的父结点是红色，叔叔结点是黑色，且当前结点是其父结点的右孩子。</strong></li>
</ul>
<p><img src="https://i.imgur.com/aKIQDEE.png" alt=""></p>
<pre><code>平衡操作：

(01) 将“父结点”作为“新的当前结点”。

(02) 以“新的当前结点”为支点进行左旋。
</code></pre><p><img src="https://i.imgur.com/6bD3SH8.png" alt=""></p>
<p>原先的父结点为当前结点，需要case3再次操作，直至满足红黑树的五个性质。</p>
<ul>
<li><strong>Case3: 当前结点的父结点是红色，叔叔结点是黑色，且当前结点是其父结点的左孩子    。</strong></li>
</ul>
<p><img src="https://i.imgur.com/2sjxlCF.png" alt=""></p>
<pre><code>平衡操作：

(01) 将“父结点”设为“黑色”。

(02) 将“祖结节点”设为“红色”。

(03) 以“祖父结点”为支点进行右旋。
</code></pre><p><img src="https://i.imgur.com/OYA3bH1.png" alt=""></p>
<h2 id="3-5-删除操作"><a href="#3-5-删除操作" class="headerlink" title="3.5 删除操作"></a>3.5 删除操作</h2><p>将红黑树内的某一个结点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该结点从二叉查找树中删除；然后，通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：</p>
<p><strong>第一步：将红黑树当作一颗二叉查找树，将结点删除。</strong></p>
<p>  这和”删除常规二叉查找树中删除结点的方法是一样的”。分3种情况：</p>
<ol>
<li>被删除结点没有儿子，即为叶结点。那么，直接将该结点删除就OK了。</li>
<li>被删除结点只有一个儿子。那么，直接删除该结点，并用该结点的唯一子结点顶替它的位置。</li>
<li>被删除结点有两个儿子。那么，先找出它的后继结点；然后把“它的后继结点的内容”复制给“该结点的内容”；之后，删除“它的后继结点”。在这里，后继结点相当于替身，在将后继结点的内容复制给”被删除结点”之后，再将后继结点删除。这样就巧妙的将问题转换为”删除后继结点”的情况了，下面就考虑后继结点。 在”被删除结点”有两个非空子结点的情况下，它的后继结点不可能是双子非空。既然”的后继结点”不可能双子都非空，就意味着”该结点的后继结点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况1 “进行处理；若只有一个儿子，则按”情况2 “进行处理。</li>
</ol>
<p><strong>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</strong></p>
<p>因为”第一步”中删除结点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p>
<p>删除分为以下几种情况:</p>
<ol>
<li><strong>待删除结点是红色的。</strong><br>直接删除，该红黑树的五个性质不受影响。</li>
<li><strong>待删除结点是黑色的，且是根结点。</strong><br>把新的根结点<br>③ 情况说明：x是“黑+黑”结点，且x不是根。<br> 处理方法：这种情况又可以划分为4种子情况。这4种子情况如下表所示：</li>
</ol>
<h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h1><hr>
<p><a href="https://www.sohu.com/a/156886901_479559" target="_blank" rel="noopener">https://www.sohu.com/a/156886901_479559</a><br><a href="https://www.jianshu.com/p/6f68d3c118d6" target="_blank" rel="noopener">https://www.jianshu.com/p/6f68d3c118d6</a><br><a href="https://blog.csdn.net/whoamiyang/article/details/51926985" target="_blank" rel="noopener">https://blog.csdn.net/whoamiyang/article/details/51926985</a><br><a href="https://www.jianshu.com/p/86a1fd2d7406" target="_blank" rel="noopener">https://www.jianshu.com/p/86a1fd2d7406</a><br><a href="http://www.cnblogs.com/skywang12345/p/3245399.html" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/3245399.html</a><br><a href="https://blog.csdn.net/sun_tttt/article/details/65445754" target="_blank" rel="noopener">https://blog.csdn.net/sun_tttt/article/details/65445754</a><br><a href="https://blog.csdn.net/guoziqing506/article/details/64122287" target="_blank" rel="noopener">https://blog.csdn.net/guoziqing506/article/details/64122287</a><br><a href="https://blog.csdn.net/popvip44/article/details/53454996" target="_blank" rel="noopener">https://blog.csdn.net/popvip44/article/details/53454996</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/B树-B-树-红黑树/" rel="tag"># B树 B+树 红黑树</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/01/前后端分离项目共享cookie实现总结 —— cookie跨域共享/" rel="next" title="前后端分离项目共享cookie实现总结 —— cookie跨域共享">
                <i class="fa fa-chevron-left"></i> 前后端分离项目共享cookie实现总结 —— cookie跨域共享
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/02/Mysql Mysql索引 联合索引 最左匹配/" rel="prev" title="mysyl知识点总结1 —— mysql联合索引最左前缀匹配">
                mysyl知识点总结1 —— mysql联合索引最左前缀匹配 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Zhang ChenYang" />
            
              <p class="site-author-name" itemprop="name">Zhang ChenYang</p>
              <p class="site-description motion-element" itemprop="description">java小白记录成长之路</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
              </a>
            </div>
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-B树"><span class="nav-text">1. B树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-基本原理"><span class="nav-text">1.1 基本原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-基本结构"><span class="nav-text">1.2 基本结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-查找关键字"><span class="nav-text">1.3 查找关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-插入关键字"><span class="nav-text">1.4 插入关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-删除关键字"><span class="nav-text">1.5 删除关键字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-B-树"><span class="nav-text">2. B+树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-基本原理"><span class="nav-text">2.1 基本原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-查找关键字"><span class="nav-text">2.2 查找关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-添加关键字"><span class="nav-text">2.3 添加关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-删除关键字"><span class="nav-text">2.4 删除关键字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-红黑树"><span class="nav-text">3. 红黑树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-基本原理"><span class="nav-text">3.1 基本原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-为什么有红黑树？"><span class="nav-text">3.2 为什么有红黑树？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-查找操作"><span class="nav-text">3.3 查找操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-旋转操作"><span class="nav-text">3.3 旋转操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-插入操作"><span class="nav-text">3.4 插入操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-删除操作"><span class="nav-text">3.5 删除操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-参考"><span class="nav-text">4. 参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang ChenYang</span>

  
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
<style>#forkongithub a{background:#000;color:#fff;text-decoration:none;font-family:arial,sans-serif;text-align:center;font-weight:bold;padding:5px 40px;font-size:1rem;line-height:2rem;position:relative;transition:0.5s;}#forkongithub a:hover{background:#fff;color:#000;}#forkongithub a::before,#forkongithub a::after{content:"";width:100%;display:block;position:absolute;top:1px;left:0;height:1px;background:#fff;}#forkongithub a::after{bottom:1px;top:auto;}@media screen and (min-width:800px){#forkongithub{position:fixed;display:block;top:0;right:0;width:200px;overflow:hidden;height:200px;z-index:9999;}#forkongithub a{width:200px;position:absolute;top:60px;right:-60px;transform:rotate(45deg);-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);-moz-transform:rotate(45deg);-o-transform:rotate(45deg);box-shadow:4px 4px 10px rgba(0,0,0,0.8);}}</style><span id="forkongithub"><a href="https://github.com/mameba">Fork me on GitHub</a></span>
</html>
